---
title: "PROJECT I: MovieLens"
author: "FH"
date: "September 30, 2020"
---output: html_document
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Inroduction

The analysis performed within this project is using analysis strategies of a recommendation system developed by the winners of the *Netflix challenge*. Since Netflix data is not publicly available the data used to develop a recommendation system is based on the **MovieLens** data. The original "MovieLens"(20M) data set was generated by the GroupLens research lab and can be found here:&nbsp; 
- MovieLens for 20M dataset &nbsp;
https://grouplens.org/datasets/movielens/20m/ &nbsp;
- MovieLens for 10M dataset &nbsp;
https://grouplens.org/datasets/movielens/10m/ &nbsp;


The recommendations were developed for the **edx** data which is a subset of the **MovieLens** data. For the evaluation of the recommendation algorithm a **validation** data set was generated. The **validation** data set was only used in the final step to test the final algorithm and contained only 10% of **edx** data. The final model with the smallest RMSE was chosen to be applied on **edx** data to calculate the parameters of the model. In last step this model was evaluated by calculating RMSE(residual mean squared error) on the **validation** set. 
&nbsp;
Following libraries were loaded:

```{r  message=FALSE}
library(dslabs)
library(tidyverse)
library(caret)
library(dplyr)
library(lubridate)
library(ggplot2)
library(gridExtra)
library(data.table)
```




```{r message=FALSE}
#  Code to generate edx data set
ratings <- fread(text = gsub("::", "\t", readLines("ml-10M100K/ratings.dat")),
                 col.names = c("userId", "movieId", "rating", "timestamp"))
movies <- str_split_fixed(readLines("ml-10M100K/movies.dat"), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")
movies <- as.data.frame(movies, stringsAsFactors=TRUE) %>%
  mutate(movieId = as.numeric(levels(movieId))[movieId], 
         title = as.character(title),
         genres = as.character(genres))
movielens <- left_join(ratings, movies, by = "movieId")

```

```{r message=FALSE}
#  Code to generate the validation set
set.seed(675)
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

validation <- temp %>% 
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(ratings, movies, test_index, temp, movielens, removed)
```

## Data Exploration and Data Processing
The **edx** data set contains 9,000,055 observations and 6 variables represented in 6 total columns. Each row represents one user giving one rating to one specific movie. &nbsp;

```{r message=FALSE}
#  Number of variables
ncol(edx)
```

```{r }
#  Number of observarions
nrow(edx)
```

The generated data set **edx** contains no missing data and consists of following variables:&nbsp;

- *movieId* is a numerical variable denotes id's for each movie  &nbsp;
- *title* is a string variable describing the title of a movie &nbsp;
- *year* numerical variable with the year of movie release from 1902 to 2016 &nbsp;
- *genres* is a categorical variable that represent 19 different genres &nbsp;
- *userId* a numerical variable to identify unique users &nbsp;
- *rating* a numerical variable from 0 to 5 &nbsp;
- *timestamp* represents time when rating was given in seconds since January 1, 1970 &nbsp;

```{r }
summary(edx)
```
&nbsp;

Before using the data for visualization and analysis several steps of data transformation were proceeded. The variable *title*" was split in 2 variables *title* and *release_year*. The variable *timestamp* was transformed to a year format and called *rating_year*. *age_years* was created as a difference between *release_year* and *rating_year*. The original *genres* variable represents a combination of several genres, for the purpose of data exploration this variable was split into 19 distinct genres and was only used to create plots. &nbsp;

```{r echo = FALSE}
#  Split title and year into separate columns by using regex
edx<-extract(edx, title, c("title", "release_year"), "(.*)\\((\\d{4})\\)$")

#  Convert year character into to an integer
edx<-transform(edx, release_year = as.numeric(release_year))

#  Transform the rating timestamp to datetime year
edx<-transform(edx, rating_year = year(as_datetime(timestamp))) 

#  Create an age_years variable that represents time in years
#  between release time and time when rating was given
edx<-edx%>%mutate(age_years=as.numeric(rating_year)-as.numeric(release_year))%>%filter(age_years>=0)

# Validation Data processing

#  Split title and year into separate columns by using regex
validation<-extract(validation, title, c("title", "release_year"), "(.*)\\((\\d{4})\\)$")

#  Convert year character into to an integer
validation<-transform(validation, release_year = as.numeric(release_year))

#  Transform the rating timestamp to datetime year
validation<-transform(validation, rating_year = year(as_datetime(timestamp)))

#  Create an age_years variable that represents time in years
#  between release time and time when rating was given
validation<-validation%>%mutate(age_years=as.numeric(rating_year)-as.numeric(release_year))%>%filter(age_years>=0)
```

```{r}
#  Check missing values
sum(is.na(edx))
```

```{r}
head(edx,10)
```

## - Users and Movies 
There are 69878 unique users, 10677 movies and 10407 movie titles in the **edx** data set. &nbsp;
```{r }
#  Number of unique users, movies and movie titles in edx
edx %>%summarize(n_users  = n_distinct(userId),
                 n_movies = n_distinct(movieId),
                 n_title  = n_distinct(title))
```
&nbsp;
```{r}
#  Top 10 of movies with greatest number of ratings
edx%>%group_by(movieId, title)%>%
  summarise(count = n())%>%arrange(desc(count))%>%
  top_n(10, count)
```
&nbsp;

As we can see the distribution of rating count among the number of movies and number of users is skewed. Not all users were equally active in giving rating and some movies received more ratings than other. For this reason movie and user effect were taken into modeling the prediction of rating.

```{r echo=FALSE}
options(scipen = 999)
p_1<-edx %>% 
  count(movieId) %>% 
  ggplot(aes(n, y=..density..)) + 
  geom_histogram(bins=30, fill=I("blue"), col=I("red"), alpha=.2) +
  scale_x_continuous(trans = "log10") + 
  geom_density(col = "black", lwd=0.2)+
  labs(x="n Movies", y="Proportions of n Ratings")+
  theme(plot.title = element_text(hjust = 0.5))

p_2<-edx %>% 
  count(userId) %>% 
  ggplot(aes(n, y=..density..)) + 
  geom_histogram(bins=30, fill=I("grey"), col=I("red"), alpha=.2) +
  scale_x_continuous(trans = "log10") + 
  geom_density(col = "black", lwd=0.2)+
  labs(x="n Users" , y="Proportion of n Ratings") +
  theme(plot.title = element_text(hjust = 0.5))

p<-grid.arrange(p_1, p_2, nrow = 1)

```

## - Distribution of Ratings  

The most given ratings were 4.0 and 3.0. Different numbers of ratings among different ratings indicate that users were more likely to give a rating then they liked a movie. Full ratings outnumbered the half ratings.
```{r echo=FALSE}
#  Number of ratings given each rating categories from 0.5 to 5 stars
edx %>% ggplot(aes(rating)) + geom_bar(fill=I("blue"), col=I("grey"), alpha=.2)+
  scale_x_continuous(breaks=seq(0, 5, by= 0.5))+
  ggtitle("Number of Ratings") +
  labs(x="Ratings", y="n of Ratings")+
  theme(plot.title = element_text(hjust = 0.5))
```
&nbsp;

## - Genre
In order to demonstrate the effect of genre the *genres* variable was transformed into a single column per genre. There were 19 unique genres and one category  with no listed genres.
```{r echo=FALSE}
#  Split genres into single columns per genre, rename in edx_genre
edx_genre<-separate_rows(edx, genres, sep = "\\|")
```

```{r }
#  Number of different genres
edx_genre%>%summarize(genre = n_distinct(genres))
```

&nbsp;

Number of ratings for each genre shows that "Drama", "Comedy" and "Action" were top 3 genres that received the most ratings. "Film-Noir", "Documentaries" and  "IMAX" received the least number of ratings.  
```{r echo=FALSE}
#  Number of ratings for each genre
edx_genre %>% group_by(genres) %>% 
  summarize(count=n())%>%
  ggplot(aes(x= reorder(genres, count), y=count))+
  geom_bar(stat='identity', color="blue")+
  ggtitle("Number of Ratings for each Genre") +
  coord_flip(y=c(0, 5000000))+
  labs(x="Genre", y="n Ratings")+
  geom_text(aes(label= count), hjust=-0.1, size=3) +
  theme(plot.title = element_text(hjust = 0.5))
```
&nbsp;

Number of ratings over years when rating was given for each genre. "Drama" remained a popular choice over years by receiving the most number of positive ratings from 4.0 and above. As it is shown in the plot below, "Drama" and "Comedy" received the highest number of rating 4.0 and above in year 2000, while "Documentary" remained flat over years.
```{r echo=FALSE}
#  Change format from scientific to normal
options(scipen = 999)
edx_genre%>%na.omit() %>% filter(rating>4)%>% mutate(genres = as.factor(genres))%>%
  group_by(genres,rating_year)%>%
  summarise(count=n())%>%filter(count > 1000)%>%
  arrange(desc(count))%>%
  ggplot(aes(rating_year, count, color = genres))+
  geom_line()+
  ggtitle("Number of Ratings over Years of Rating") +
  labs(x="Rating Years", y="n of Ratings") +
  scale_x_continuous(limits=c(1995, 2008, by=1))+
  theme(plot.title = element_text(hjust = 0.5))
```
&nbsp;

Following Box plots show how the ratings for each genre are spread in **edx** data. For example "Film-Noir" shows the highest percentage on positive ratings although this genre received only few ratings compared to other genres. Similarly, "Documentary" is a highly rated genre with not many ratings.

```{r echo=FALSE}
edx_genre%>%filter(genres  %in% c("Drama”, “Comedy", "Action", "Thriller", "Adventure", "Romance", "Sci-Fi", "Crime", "Fantasy", 
                                  "Children", "Horror", "Mystery", "War", "Animation", "Musical", "Western", "Film-Noir", "Documentary", "IMAX" ))%>%
  mutate(count = n(), avg_rating = mean(rating), se_rating = sd(rating)/sqrt(count))%>%
  ggplot(aes(x = reorder(genres, rating), y = rating))+
  geom_boxplot()+
  ggtitle("Boxplot by Genre") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab(" ")+
  ylab("Rating")+
  theme(plot.title = element_text(hjust = 0.5))
  

```

## - Time 

There are 3 different variables defining time in the **edx** data set:  *rating_year*, *release_year* and *age_years*. Over the years the average rating remained over 3.0 ranging around rating 3.5.

```{r echo=FALSE}
#  Average rating over years when rating was given

edx %>% group_by(rating_year) %>%summarize(avg_rating = mean(rating)) %>%
  ggplot(aes(rating_year, avg_rating)) +
  geom_point() + geom_smooth()+
  scale_y_continuous(breaks=seq(0, 5, by= 0.5))+
  scale_x_continuous(breaks=seq(1995, 2018, by= 5))+
  ggtitle("Average Rating over Rating Year") +
  labs(x="Rating Year" , y="Average Rating") +
  theme(plot.title = element_text(hjust = 0.5))
```


In comparison between years when movie was first released with years when rating was given. Movies released long time ago don't contain enough data point and show higher variability. 

```{r echo=FALSE}
#  Average rating over release years
edx%>%group_by(release_year)%>%
  mutate(count=n(), avg_rating=mean(rating))%>%
  ggplot(aes(release_year, avg_rating))+
  geom_point()+geom_smooth()+
  ggtitle("Average Rating over Release Years") +
  labs(x="Release Year" , y="Average Rating") +
  theme(plot.title = element_text(hjust = 0.5))
```

&nbsp;

The average rating went up with time past the release date but dropped again for movies older than 70 years.
```{r echo=FALSE}
#  Average rating over the age of movies
edx%>%group_by(age_years) %>% summarize(avg_rating = mean(rating))%>%arrange(desc(avg_rating))%>%
  ggplot(aes(age_years, avg_rating)) +
  scale_x_continuous(breaks=seq(0, 100, by= 10))+
  geom_point() + geom_smooth()+
  ggtitle("Average Rating over Movie Age") +
  labs(x="Age of Movie" , y="Average Rating") +
  theme(plot.title = element_text(hjust = 0.5))
```





# Method Section

It was important NOT to use the **validation** set to train the algorithm. The **edx** data was split into a **train_set** and **test_set**, where the test_set was set to 20% of the **edx data**. The **train_set** was used to train all model, while **test_set** was used to estimate predictions of ratings and to calculate the RMSE in order to evaluate the model. &nbsp;
```{r}
set.seed(110)
test_index <- createDataPartition(y=edx$rating, times = 1, p = 0.2, list = FALSE)
test_set <- edx[test_index, ]
train_set <- edx[-test_index, ]  
```
semi_join function removes entries for users and movies in test_set that dont's appear in th train_set.

`````{r}
test_set <- test_set %>% 
  semi_join(train_set, by = "movieId") %>%
  semi_join(train_set, by = "userId")
````


There were 7 possible predictors of rating: *genres*, *release_year*, *rating_year*, *movieId*, *userId*, *title*, *age_years*. Models based on one and a combination of several predictors were tested on the **train_set**. The **test_set** was used to calculate RMSE of each model as it was done in the *Netflix challenge*. RMSE's of multiple models were compared with each other. After the comparison model that yielded the smallest RMSE was used for the final evaluation on the **validation** set to test the final algorithm. **RMSE < 0.86490** was considered acceptable.
&nbsp;

The RMSE (residual mean squared error) is defined as:
&nbsp;

$\begin{align}RMSE = \sqrt{\frac{1}{N}\sum_{u,m}(\hat y_{u,m}-y_{u,m})^2}\end{align}$ 
&nbsp;

Where $y_{u,i}$ is rating by user $u$ for movie $m$ and $\hat y_{u,m}$ is the prediction of the rating. $N$ is a number of movie and users.
&nbsp;

Following code for RMSE was used
```{r }
RMSE <- function(true_ratings, predicted_ratings){
  sqrt(mean((true_ratings-predicted_ratings)^2, na.rm = T))
}
```






Important: The validation data (the final hold-out test set) should NOT be used for training your algorithm and should ONLY be used for evaluating the RMSE of your final algorithm. You should split the edx data into separate training and test sets to design and test your algorithm.



Explain the method and techniques used, Visualization with insights, data exploration. Use at least two Methods 
You will use the following code to generate your data sets. Develop your algorithm using the edx set. For a final test of your algorithm, predict movie ratings in the validation set (the final hold-out test set) as if they were unknown. RMSE will be used to evaluate how close your predictions are to the true values in the validation set (the final hold-out test set).

Prediction Performance
RMSE in validation data set >90?

# Results Section
## Model performance. 
For a final test of the algorithm, predict movie ratings were predicted in the validation set  as if they were unknown. RMSE was used to evaluate how close predictions of rating were to the true values in the validation set.




# Conclusion Section

Brief summary of the report. It's limitation and future work.

[^1]: http://bits.blogs.nytimes.com/2009/09/21/netflix-awards-1-million-prize-and-starts-a-new-contest/ &nbsp;
[^2]: https://grouplens.org/
